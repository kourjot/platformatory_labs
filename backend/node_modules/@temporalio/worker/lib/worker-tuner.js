"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.asNativeTuner = asNativeTuner;
const time_1 = require("@temporalio/common/lib/time");
function asNativeTuner(tuner, logger) {
    if (isTunerHolder(tuner)) {
        let tunerOptions = undefined;
        const retme = {
            workflowTaskSlotSupplier: nativeifySupplier(tuner.workflowTaskSlotSupplier, 'workflow', logger),
            activityTaskSlotSupplier: nativeifySupplier(tuner.activityTaskSlotSupplier, 'activity', logger),
            localActivityTaskSlotSupplier: nativeifySupplier(tuner.localActivityTaskSlotSupplier, 'activity', logger),
        };
        for (const supplier of [
            retme.workflowTaskSlotSupplier,
            retme.activityTaskSlotSupplier,
            retme.localActivityTaskSlotSupplier,
        ]) {
            if (isResourceBased(supplier)) {
                if (tunerOptions !== undefined) {
                    if (tunerOptions !== supplier.tunerOptions) {
                        throw new TypeError('Cannot construct worker tuner with multiple different tuner options');
                    }
                }
                else {
                    tunerOptions = supplier.tunerOptions;
                }
            }
        }
        return retme;
    }
    else if (isResourceBasedTuner(tuner)) {
        const wftSO = addResourceBasedSlotDefaults(tuner.workflowTaskSlotOptions ?? {}, 'workflow');
        const atSO = addResourceBasedSlotDefaults(tuner.activityTaskSlotOptions ?? {}, 'activity');
        const latSO = addResourceBasedSlotDefaults(tuner.localActivityTaskSlotOptions ?? {}, 'activity');
        return {
            workflowTaskSlotSupplier: {
                type: 'resource-based',
                tunerOptions: tuner.tunerOptions,
                ...wftSO,
                rampThrottleMs: (0, time_1.msToNumber)(wftSO.rampThrottle),
            },
            activityTaskSlotSupplier: {
                type: 'resource-based',
                tunerOptions: tuner.tunerOptions,
                ...atSO,
                rampThrottleMs: (0, time_1.msToNumber)(atSO.rampThrottle),
            },
            localActivityTaskSlotSupplier: {
                type: 'resource-based',
                tunerOptions: tuner.tunerOptions,
                ...latSO,
                rampThrottleMs: (0, time_1.msToNumber)(latSO.rampThrottle),
            },
        };
    }
    else {
        throw new TypeError('Invalid worker tuner configuration');
    }
}
const isResourceBasedTuner = (tuner) => Object.hasOwnProperty.call(tuner, 'tunerOptions');
const isTunerHolder = (tuner) => Object.hasOwnProperty.call(tuner, 'workflowTaskSlotSupplier');
const isResourceBased = (sup) => sup.type === 'resource-based';
const isCustom = (sup) => sup.type === 'custom';
const abortString = '__ABORTED_BY_CORE__';
class ErrorLoggingSlotSupplier {
    constructor(supplier, logger) {
        this.supplier = supplier;
        this.logger = logger;
        this.type = 'custom';
    }
    async reserveSlot(ctx, registerAbort) {
        const abortController = new AbortController();
        registerAbort(() => abortController.abort(abortString));
        return await this.supplier.reserveSlot(ctx, abortController.signal).catch((err) => {
            if (err !== abortString) {
                this.logger.error('Error in custom slot supplier `reserveSlot`', err);
            }
            throw err;
        });
    }
    tryReserveSlot(ctx) {
        try {
            return this.supplier.tryReserveSlot(ctx);
        }
        catch (err) {
            this.logger.error('Error in custom slot supplier `tryReserveSlot`', err);
        }
        return null;
    }
    markSlotUsed(ctx) {
        try {
            this.supplier.markSlotUsed(ctx);
        }
        catch (err) {
            this.logger.error('Error in custom slot supplier `markSlotUsed`', err);
        }
    }
    releaseSlot(ctx) {
        try {
            this.supplier.releaseSlot(ctx);
        }
        catch (err) {
            this.logger.error('Error in custom slot supplier `releaseSlot`', err);
        }
    }
}
function nativeifySupplier(supplier, kind, logger) {
    if (isResourceBased(supplier)) {
        const tunerOptions = supplier.tunerOptions;
        const defaulted = addResourceBasedSlotDefaults(supplier, kind);
        return {
            ...defaulted,
            type: 'resource-based',
            tunerOptions,
            rampThrottleMs: (0, time_1.msToNumber)(defaulted.rampThrottle),
        };
    }
    if (isCustom(supplier)) {
        return new ErrorLoggingSlotSupplier(supplier, logger);
    }
    return supplier;
}
function addResourceBasedSlotDefaults(slotOptions, kind) {
    if (kind === 'workflow') {
        return {
            minimumSlots: slotOptions.minimumSlots ?? 2,
            maximumSlots: slotOptions.maximumSlots ?? 1000,
            rampThrottle: slotOptions.rampThrottle ?? 10,
        };
    }
    else {
        return {
            minimumSlots: slotOptions.minimumSlots ?? 1,
            maximumSlots: slotOptions.maximumSlots ?? 2000,
            rampThrottle: slotOptions.rampThrottle ?? 50,
        };
    }
}
//# sourceMappingURL=worker-tuner.js.map